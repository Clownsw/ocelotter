use byteorder::{BigEndian, ByteOrder};
use std::io::Read;
use std::str;
use super::*;

pub const ACC_PUBLIC: u16 = 0x0001; // Declared public; may be accessed from outside its package.
pub const ACC_PRIVATE: u16 = 0x0002; // Declared private; usable only within the defining class.
pub const ACC_PROTECTED: u16 = 0x0004; // Declared protected; may be accessed within subclasses.
pub const ACC_STATIC: u16 = 0x0008; // Declared static

pub const ACC_FINAL: u16 = 0x0010; // Declared final; no subclasses allowed.
pub const ACC_SUPER: u16 = 0x0020; // (Class) Treat superclass methods specially when invoked by the invokespecial instruction.
pub const ACC_VOLATILE: u16 = 0x0040; // (Field) Declared volatile; cannot be cached.
pub const ACC_TRANSIENT: u16 = 0x0080; // (Field) Declared transient; not written or read by a persistent object manager.
pub const ACC_INTERFACE: u16 = 0x0200; // (Class) Is an interface, not a class.
pub const ACC_ABSTRACT: u16 = 0x0400; // (Class) Declared abstract; must not be instantiated.
pub const ACC_SYNTHETIC: u16 = 0x1000; // Declared synthetic; not present in the source code.
pub const ACC_ANNOTATION: u16 = 0x2000; // Declared as an annotation type.
pub const ACC_ENUM: u16 = 0x4000; // Declared as an enum type.

// Method-only constants
pub const ACC_SYNCHRONIZED: u16 = 0x0020; // (Method) Declared synchronized; invocation is wrapped by a monitor use.
pub const ACC_BRIDGE: u16 = 0x0040; // (Method) A bridge, generated by the compiler.
pub const ACC_VARARGS: u16 = 0x0080; // (Method) Declared with variable number of arguments.
pub const ACC_NATIVE: u16 = 0x0100; // (Method) Declared native; implemented in a language other than Java.
pub const ACC_ABSTRACT_M: u16 = 0x0400; // (Method) Declared abstract; no implementation is provided.
pub const ACC_STRICT: u16 = 0x0800; // (Method) Declared strictfp; floating-point mode is FP-strict.

// CPType constants
pub const UTF8: u8 = 1;
pub const INTEGER: u8 = 3;
pub const FLOAT: u8 = 4;
pub const LONG: u8 = 5;
pub const DOUBLE: u8 = 6;
pub const CLASS: u8 = 7;
pub const STRING: u8 = 8;
pub const FIELDREF: u8 = 9;
pub const METHODREF: u8 = 10;
pub const INTERFACE_METHODREF: u8 = 11;
pub const NAMEANDTYPE: u8 = 12;
pub const METHODHANDLE: u8 = 15;
pub const METHODTYPE: u8 = 16;
pub const INVOKEDYNAMIC: u8 = 18;

pub enum cp_entry {
    utf8 { val: String },
    integer { val: i32 },
    float { val: f32 },
    long { val: i64 },
    double { val: f64 },
    class { idx: u16 },
    string { idx: u16 },
    fieldref { clz_idx: u16, nt_idx: u16 },
    methodref { clz_idx: u16, nt_idx: u16 },
    interface_methodref { clz_idx: u16, nt_idx: u16 },
    name_and_type { name_idx: u16, type_idx: u16 },
}

impl cp_entry {
    pub fn separator(cp_type: u8) -> String {
        match cp_type {
            FIELDREF => ".".to_string(),
            METHODREF => ".".to_string(),
            NAMEANDTYPE => ":".to_string(),
            _ => "".to_string(),
        }
    }
}

pub struct oc_parser {
    clz_read: Vec<u8>,
    filename: String,
    current: usize,
    major: u16,
    minor: u16,

    poolItemCount: u16,
    flags: u16,
    cp_index_this: u16,
    cp_index_super: u16,
    cp_items: Vec<cp_entry>,
    interfaces: Vec<u16>,
    // private int[] interfaces;
    // private CPField[] fields;
    // private CPMethod[] methods;
    // private CPAttr[] attributes;
}

impl oc_parser {
    pub fn new(buf: Vec<u8>, fname: String) -> oc_parser {
        oc_parser {
            clz_read: buf,
            filename: fname,
            current: 0,
            major: 0,
            minor: 0,
            poolItemCount: 0,
            flags: 0,
            cp_index_this: 0,
            cp_index_super: 0,
            cp_items: Vec::new(),
            interfaces: Vec::new(),
        }
    }

    pub fn klass(&mut self) -> runtime::OCKlass {
        // Lookup the name in the CP - this should probably become a helper method
        // Note that CP indices are 1-indexed
        let klass_name = match self.cp_items[(self.cp_index_this - 1) as usize] {
            cp_entry::class{idx: icl} => match &self.cp_items[(icl - 1) as usize] {
                cp_entry::utf8{val: s} => s,
                _ => panic!("Class index {} does not point at utf8 string in constant pool", icl)
            },
            _ => panic!("Self-index {} does not point at class element in constant pool", self.cp_index_this)
        };
        runtime::OCKlass::of(klass_name.to_string())
    }

    pub fn parse(&mut self) -> () {
        self.parse_header();
        self.parse_constant_pool();
        self.parse_basic_type_info();
        // self.parseFields();
        // self.parseMethods();
        //        self.parseAttributes();
    }

    pub fn get_pool_size(&self) -> u16 {
        self.poolItemCount
    }

    // Impl methods
    fn parse_header(&mut self) -> () {
        if self.clz_read[0] != 0xca
            || self.clz_read[1] != 0xfe
            || self.clz_read[2] != 0xba
            || self.clz_read[3] != 0xbe
        {
            panic!(
                "Input file {} does not have correct magic number",
                self.filename
            );
        }

        self.minor = ((self.clz_read[4] as u16) << 8) + self.clz_read[5] as u16;
        self.major = ((self.clz_read[6] as u16) << 8) + self.clz_read[7] as u16;
        self.poolItemCount = ((self.clz_read[8] as u16) << 8) + self.clz_read[9] as u16;
    }

    fn parse_constant_pool(&mut self) -> () {
        self.current = 10;
        // println!("Pool size: {}", self.get_pool_size());
        for i in 1..self.poolItemCount {
            let tag = self.clz_read[self.current];
            // println!("Seen: {}", tag);
            self.current += 1;
            let item = match tag {
                UTF8 => {
                    // println!("Parsing a utf8");
                    let b1 = self.clz_read[self.current];
                    let b2 = self.clz_read[self.current + 1];
                    self.current += 2;

                    let len = ((b1 as u16) << 8) + b2 as u16;

                    let mut buf = vec![];
                    let mut chunk = self.clz_read[self.current..].take(len as u64);
                    chunk.read_to_end(&mut buf);
                    self.current += len as usize;

                    let str_c = match str::from_utf8(&buf) {
                        Ok(v) => v,
                        Err(e) => panic!("{}", e),
                    }
                    .to_owned();
                    cp_entry::utf8 { val: str_c }
                }
                INTEGER => {
                    let b1 = self.clz_read[self.current];
                    let b2 = self.clz_read[self.current + 1];
                    let b3 = self.clz_read[self.current + 2];
                    let b4 = self.clz_read[self.current + 3];
                    self.current += 4;

                    let buf = &[b1, b2, b3, b4];
                    cp_entry::integer {
                        val: BigEndian::read_i32(buf),
                    }
                }
                FLOAT => {
                    let b1 = self.clz_read[self.current];
                    let b2 = self.clz_read[self.current + 1];
                    let b3 = self.clz_read[self.current + 2];
                    let b4 = self.clz_read[self.current + 3];
                    self.current += 4;

                    let buf = &[b1, b2, b3, b4];
                    cp_entry::float {
                        val: BigEndian::read_f32(buf),
                    }
                }
                LONG => {
                    let b1 = self.clz_read[self.current];
                    let b2 = self.clz_read[self.current + 1];
                    let b3 = self.clz_read[self.current + 2];
                    let b4 = self.clz_read[self.current + 3];
                    let b5 = self.clz_read[self.current + 4];
                    let b6 = self.clz_read[self.current + 5];
                    let b7 = self.clz_read[self.current + 6];
                    let b8 = self.clz_read[self.current + 7];
                    self.current += 8;

                    let buf = &[b1, b2, b3, b4, b5, b6, b7, b8];
                    cp_entry::long {
                        val: BigEndian::read_i64(buf),
                    }
                }
                DOUBLE => {
                    let b1 = self.clz_read[self.current];
                    let b2 = self.clz_read[self.current + 1];
                    let b3 = self.clz_read[self.current + 2];
                    let b4 = self.clz_read[self.current + 3];
                    let b5 = self.clz_read[self.current + 4];
                    let b6 = self.clz_read[self.current + 5];
                    let b7 = self.clz_read[self.current + 6];
                    let b8 = self.clz_read[self.current + 7];
                    self.current += 8;

                    let buf = &[b1, b2, b3, b4, b5, b6, b7, b8];
                    cp_entry::double {
                        val: BigEndian::read_f64(buf),
                    }
                }
                CLASS => {
                    // println!("Parsing a class");
                    let b1 = self.clz_read[self.current];
                    let b2 = self.clz_read[self.current + 1];
                    self.current += 2;

                    cp_entry::class {
                        idx: ((b1 as u16) << 8) + b2 as u16,
                    }
                }
                STRING => {
                    let b1 = self.clz_read[self.current];
                    let b2 = self.clz_read[self.current + 1];
                    self.current += 2;

                    cp_entry::string {
                        idx: ((b1 as u16) << 8) + b2 as u16,
                    }
                }
                FIELDREF => {
                    // println!("Parsing a fieldref");
                    let b1 = self.clz_read[self.current];
                    let b2 = self.clz_read[self.current + 1];
                    let b3 = self.clz_read[self.current + 2];
                    let b4 = self.clz_read[self.current + 3];
                    self.current += 4;

                    cp_entry::fieldref {
                        clz_idx: ((b1 as u16) << 8) + b2 as u16,
                        nt_idx: ((b3 as u16) << 8) + b4 as u16,
                    }
                }
                METHODREF => {
                    // println!("Parsing a methodref");
                    let b1 = self.clz_read[self.current];
                    let b2 = self.clz_read[self.current + 1];
                    let b3 = self.clz_read[self.current + 2];
                    let b4 = self.clz_read[self.current + 3];
                    self.current += 4;

                    cp_entry::methodref {
                        clz_idx: ((b1 as u16) << 8) + b2 as u16,
                        nt_idx: ((b3 as u16) << 8) + b4 as u16,
                    }
                }
                INTERFACE_METHODREF => {
                    // println!("Parsing an interface_methodref");
                    let b1 = self.clz_read[self.current];
                    let b2 = self.clz_read[self.current + 1];
                    let b3 = self.clz_read[self.current + 2];
                    let b4 = self.clz_read[self.current + 3];
                    self.current += 4;

                    cp_entry::interface_methodref {
                        clz_idx: ((b1 as u16) << 8) + b2 as u16,
                        nt_idx: ((b3 as u16) << 8) + b4 as u16,
                    }
                }
                NAMEANDTYPE => {
                    // println!("Parsing a name_and_type");
                    let b1 = self.clz_read[self.current];
                    let b2 = self.clz_read[self.current + 1];
                    let b3 = self.clz_read[self.current + 2];
                    let b4 = self.clz_read[self.current + 3];
                    self.current += 4;

                    cp_entry::name_and_type {
                        name_idx: ((b1 as u16) << 8) + b2 as u16,
                        type_idx: ((b3 as u16) << 8) + b4 as u16,
                    }
                }
                _ => panic!("Unsupported Constant Pool type {} at {}", tag, self.current),
            };
            self.cp_items.push(item);
        }
    }

    fn parse_basic_type_info(&mut self) -> () {
        self.flags = ((self.clz_read[self.current] as u16) << 8) + self.clz_read[self.current + 1] as u16;
        self.cp_index_this = ((self.clz_read[self.current + 2] as u16) << 8) + self.clz_read[self.current + 3] as u16;
        self.cp_index_super = ((self.clz_read[self.current + 4] as u16) << 8) + self.clz_read[self.current + 5] as u16;
        let count = ((self.clz_read[self.current + 6] as u16) << 8) + self.clz_read[self.current + 7] as u16;
        self.current += 8;

        for i in 0..count {
            self.interfaces.push(((self.clz_read[self.current] as u16) << 8) + self.clz_read[self.current + 1] as u16);
            self.current += 2;
        }

    }
}
