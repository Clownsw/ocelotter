use std::io::Read;
use std::str;

pub const ACC_PUBLIC: u16 = 0x0001; // Declared public; may be accessed from outside its package.
pub const ACC_PRIVATE: u16 = 0x0002; // Declared private; usable only within the defining class.
pub const ACC_PROTECTED: u16 = 0x0004; // Declared protected; may be accessed within subclasses.
pub const ACC_STATIC: u16 = 0x0008; // Declared static

pub const ACC_FINAL: u16 = 0x0010; // Declared final; no subclasses allowed.
pub const ACC_SUPER: u16 = 0x0020; // (Class) Treat superclass methods specially when invoked by the invokespecial instruction.
pub const ACC_VOLATILE: u16 = 0x0040; // (Field) Declared volatile; cannot be cached.
pub const ACC_TRANSIENT: u16 = 0x0080; // (Field) Declared transient; not written or read by a persistent object manager.
pub const ACC_INTERFACE: u16 = 0x0200; // (Class) Is an interface, not a class.
pub const ACC_ABSTRACT: u16 = 0x0400; // (Class) Declared abstract; must not be instantiated.
pub const ACC_SYNTHETIC: u16 = 0x1000; // Declared synthetic; not present in the source code.
pub const ACC_ANNOTATION: u16 = 0x2000; // Declared as an annotation type.
pub const ACC_ENUM: u16 = 0x4000; // Declared as an enum type.

// Method-only constants
pub const ACC_SYNCHRONIZED: u16 = 0x0020; // (Method) Declared synchronized; invocation is wrapped by a monitor use.
pub const ACC_BRIDGE: u16 = 0x0040; // (Method) A bridge, generated by the compiler.
pub const ACC_VARARGS: u16 = 0x0080; // (Method) Declared with variable number of arguments.
pub const ACC_NATIVE: u16 = 0x0100; // (Method) Declared native; implemented in a language other than Java.
pub const ACC_ABSTRACT_M: u16 = 0x0400; // (Method) Declared abstract; no implementation is provided.
pub const ACC_STRICT: u16 = 0x0800; // (Method) Declared strictfp; floating-point mode is FP-strict.

// CPType constants
pub const UTF8: u8 = 1;
pub const INTEGER: u8 = 3;
pub const FLOAT: u8 = 4;
pub const LONG: u8 = 5;
pub const DOUBLE: u8 = 6;
pub const CLASS: u8 = 7;
pub const STRING: u8 = 8;
pub const FIELDREF: u8 = 9;
pub const METHODREF: u8 = 10;
pub const INTERFACE_METHODREF: u8 = 11;
pub const NAMEANDTYPE: u8 = 12;
pub const METHODHANDLE: u8 = 15;
pub const METHODTYPE: u8 = 16;
pub const INVOKEDYNAMIC: u8 = 18;

pub enum cp_entry {
    utf8 { val: String },
    integer { val: i32 },
    float { val: f32 },
    long { val: i64 },
    double { val: f64 },
    class { idx: u16 },
    string { idx: u16 },
    fieldref { clz_idx: u16, nt_idx: u16 },
    methodref { clz_idx: u16, nt_idx: u16 },
    interface_methodref { clz_idx: u16, nt_idx: u16 },
    name_and_type { name_idx: u16, type_idx: u16 },
}

impl cp_entry {
    pub fn separator(cp_type: u8) -> String {
        match cp_type {
            FIELDREF => ".".to_string(),
            METHODREF => ".".to_string(),
            NAMEANDTYPE => ":".to_string(),
            _ => "".to_string(),
        }
    }
}

pub struct oc_parser {
    clz_read: Vec<u8>,
    filename: String,
    current: usize,
    major: u16,
    minor: u16,

    poolItemCount: u16,
    flags: u16,
    thisClzIndex: u16,
    superClzIndex: u16,
    items: Vec<cp_entry>,
    // private int[] interfaces;
    // private CPField[] fields;
    // private CPMethod[] methods;
    // private CPAttr[] attributes;
}

impl oc_parser {
    pub fn new(buf: Vec<u8>, fname: String) -> oc_parser {
        oc_parser {
            clz_read: buf,
            filename: fname,
            current: 0,
            major: 0,
            minor: 0,
            poolItemCount: 0,
            flags: 0,
            thisClzIndex: 0,
            superClzIndex: 0,
            items: Vec::new(),
        }
    }

    pub fn parse(&mut self) -> () {
        self.parse_header();
        self.parse_constant_pool();
        // self.parseBasicTypeInfo();
        // self.parseFields();
        // self.parseMethods();
        //        self.parseAttributes();
    }

    pub fn get_pool_size(&self) -> u16 {
        self.poolItemCount
    }

    // Impl methods
    fn get_byte(&mut self, pos: usize) -> u8 {
        0
    }

    fn parse_header(&mut self) -> () {
        if self.clz_read[0] != 0xca
            || self.clz_read[1] != 0xfe
            || self.clz_read[2] != 0xba
            || self.clz_read[3] != 0xbe
        {
            panic!(
                "Input file {} does not have correct magic number",
                self.filename
            );
        }

        self.minor = ((self.clz_read[4] as u16) << 8) + self.clz_read[5] as u16;
        self.major = ((self.clz_read[6] as u16) << 8) + self.clz_read[7] as u16;
        self.poolItemCount = ((self.clz_read[8] as u16) << 8) + self.clz_read[9] as u16;
    }

    fn parse_constant_pool(&mut self) -> () {
        self.current = 10;
        for i in 1..self.poolItemCount {
            let tag = self.clz_read[self.current];
            self.current += 1;
            let item = match tag {
                utf8 => {
                    let b1 = self.clz_read[self.current];
                    self.current += 1;
                    let b2 = self.clz_read[self.current];
                    self.current += 1;
                    let len = ((b1 as u16) << 8) + b2 as u16;

                    let mut buf = vec![];
                    let mut chunk = self.clz_read.take(len as u64);
                    chunk.read_to_end(&mut buf);

                    let str_c = match str::from_utf8(&buf) {
                        Ok(v) => v,
                        Err(e) => panic!("{}", e),
                    }
                    .to_owned();
                    cp_entry::utf8 { val: str_c }
                }
                // FIXME
                integer => cp_entry::integer { val: 0i32 },
                // FIXME
                float => cp_entry::float { val: 0.0f32 },
                // FIXME
                long => cp_entry::long { val: 0i64 },
                // FIXME
                double => cp_entry::double { val: 0.0f64 },
                class => {
                    let b1 = self.clz_read[self.current];
                    self.current += 1;
                    let b2 = self.clz_read[self.current];
                    self.current += 1;

                    cp_entry::class {
                        idx: ((b1 as u16) << 8) + b2 as u16,
                    }
                }
                // FIXME
                string => cp_entry::long { val: 0i64 },
                // FIXME
                fieldref => cp_entry::long { val: 0i64 },
                methodref => {
                    let b1 = self.clz_read[self.current];
                    self.current += 1;
                    let b2 = self.clz_read[self.current];
                    self.current += 1;
                    let b3 = self.clz_read[self.current];
                    self.current += 1;
                    let b4 = self.clz_read[self.current];
                    self.current += 1;

                    cp_entry::methodref {
                        clz_idx: ((b1 as u16) << 8) + b2 as u16,
                        nt_idx: ((b3 as u16) << 8) + b4 as u16,
                    }
                }
                // FIXME
                interface_methodref => cp_entry::long { val: 0i64 },
                name_and_type => {
                    let b1 = self.clz_read[self.current];
                    self.current += 1;
                    let b2 = self.clz_read[self.current];
                    self.current += 1;
                    let b3 = self.clz_read[self.current];
                    self.current += 1;
                    let b4 = self.clz_read[self.current];
                    self.current += 1;

                    cp_entry::name_and_type {
                        name_idx: ((b1 as u16) << 8) + b2 as u16,
                        type_idx: ((b3 as u16) << 8) + b4 as u16,
                    }
                }
                _ => panic!("Unsupported Constant Pool type {} at {}", tag, self.current),
            };
            self.items.push(item);
        }
        //     void parseConstantPool() throws ClassNotFoundException {
        //         items = new CPEntry[poolItemCount - 1];
        //         for (short i = 1; i < poolItemCount; i++) {
        //             int entry = clzBytes[current++] & 0xff;
        //             CPType tag = table[entry];
        //             if (tag == null) {
        //                 throw new ClassNotFoundException("Unrecognised tag byte: " + entry + " encountered at position " + current + ". Stopping the parse.");
        //             }

        //             CPEntry item = null;
        // //            System.out.println("Tag seen: "+ tag);
        //             // Create item based on tag
        //             switch (tag) {
        //                 case UTF8: // String prefixed by a uint16 indicating the number of bytes in the encoded string which immediately follows
        //                     int len = ((int) clzBytes[current++] << 8) + (int) clzBytes[current++];
        //                     String str = new String(clzBytes, current, len, Charset.forName("UTF8"));
        //                     item = CPEntry.of(i, tag, str);
        //                     current += len;
        //                     break;
        //                 case INTEGER: // Integer: a signed 32-bit two's complement number in big-endian format
        //                     int i2 = ((int) clzBytes[current++] << 24) + ((int) clzBytes[current++] << 16) + ((int) clzBytes[current++] << 8) + (int) clzBytes[current++];
        //                     item = CPEntry.of(i, tag, i2);
        //                     break;
        //                 case FLOAT: // Float: a 32-bit single-precision IEEE 754 floating-point number
        //                     int i3 = ((int) clzBytes[current++] << 24) + ((int) clzBytes[current++] << 16) + ((int) clzBytes[current++] << 8) + (int) clzBytes[current++];
        //                     float f = Float.intBitsToFloat(i3);
        //                     item = CPEntry.of(i, tag, f);
        //                     break;
        //                 case LONG: // Long: a signed 64-bit two's complement number in big-endian format (takes two slots in the constant pool table)
        //                     int i4 = ((int) clzBytes[current++] << 24) + ((int) clzBytes[current++] << 16) + ((int) clzBytes[current++] << 8) + (int) clzBytes[current++];
        //                     int i5 = ((int) clzBytes[current++] << 24) + ((int) clzBytes[current++] << 16) + ((int) clzBytes[current++] << 8) + (int) clzBytes[current++];
        //                     long l = ((long) i4 << 32) + (long) i5;
        //                     item = CPEntry.of(i, tag, l);
        //                     break;
        //                 case DOUBLE: // Double: a 64-bit double-precision IEEE 754 floating-point number (takes two slots in the constant pool table)
        //                     i4 = ((int) clzBytes[current++] << 24) + ((int) clzBytes[current++] << 16) + ((int) clzBytes[current++] << 8) + (int) clzBytes[current++];
        //                     i5 = ((int) clzBytes[current++] << 24) + ((int) clzBytes[current++] << 16) + ((int) clzBytes[current++] << 8) + (int) clzBytes[current++];
        //                     l = ((long) i4 << 32) + (long) i5;
        //                     item = CPEntry.of(i, tag, Double.longBitsToDouble(l));
        //                     break;
        //                 case CLASS: // Class reference: an uint16 within the constant pool to a UTF-8 string containing the fully qualified class name
        //                     int ref = ((int) clzBytes[current++] << 8) + (int) clzBytes[current++];
        //                     item = CPEntry.of(i, tag, new Ref(ref));
        //                     break;
        //                 case STRING: // String reference: an uint16 within the constant pool to a UTF-8 string
        //                     int ref2 = ((int) clzBytes[current++] << 8) + (int) clzBytes[current++];
        //                     item = CPEntry.of(i, tag, new Ref(ref2));
        //                     break;
        //                 case FIELDREF: // Field reference: two uint16 within the pool, 1st pointing to a Class reference, 2nd to a Name and Type descriptor
        //                 case METHODREF: // Method reference: two uint16s within the pool, 1st pointing to a Class reference, 2nd to a Name and Type descriptor
        //                 case INTERFACE_METHODREF: // Interface method reference: 2 uint16 within the pool, 1st pointing to a Class reference, 2nd to a Name and Type descriptor
        //                     int cpIndex = ((int) clzBytes[current++] << 8) + (int) clzBytes[current++];
        //                     int nameAndTypeIndex = ((int) clzBytes[current++] << 8) + (int) clzBytes[current++];
        //                     item = CPEntry.of(i, tag, new Ref(cpIndex), new Ref(nameAndTypeIndex));
        //                     break;
        //                 case NAMEANDTYPE: // Name and type descriptor: 2 uint16 to UTF-8 strings, 1st representing a name (identifier), 2nd a specially encoded type descriptor
        //                     int nameRef = ((int) clzBytes[current++] << 8) + (int) clzBytes[current++];
        //                     int typeRef = ((int) clzBytes[current++] << 8) + (int) clzBytes[current++];
        //                     item = CPEntry.of(i, tag, new Ref(nameRef), new Ref(typeRef));
        //                     break;
        //                 default:
        //                     throw new ClassNotFoundException("Reached impossible Constant Pool Tag.");
        //             }
        //             items[i - 1] = item;
        //         }
        //     }
    }
}
