use super::*;
use byteorder::{BigEndian, ByteOrder};
use std::fmt;
use std::io::Read;
use std::str;

pub const ACC_PUBLIC: u16 = 0x0001; // Declared public; may be accessed from outside its package.
pub const ACC_PRIVATE: u16 = 0x0002; // Declared private; usable only within the defining class.
pub const ACC_PROTECTED: u16 = 0x0004; // Declared protected; may be accessed within subclasses.
pub const ACC_STATIC: u16 = 0x0008; // Declared static

pub const ACC_FINAL: u16 = 0x0010; // Declared final; no subclasses allowed.
pub const ACC_SUPER: u16 = 0x0020; // (Class) Treat superclass methods specially when invoked by the invokespecial instruction.
pub const ACC_VOLATILE: u16 = 0x0040; // (Field) Declared volatile; cannot be cached.
pub const ACC_TRANSIENT: u16 = 0x0080; // (Field) Declared transient; not written or read by a persistent object manager.
pub const ACC_INTERFACE: u16 = 0x0200; // (Class) Is an interface, not a class.
pub const ACC_ABSTRACT: u16 = 0x0400; // (Class) Declared abstract; must not be instantiated.
pub const ACC_SYNTHETIC: u16 = 0x1000; // Declared synthetic; not present in the source code.
pub const ACC_ANNOTATION: u16 = 0x2000; // Declared as an annotation type.
pub const ACC_ENUM: u16 = 0x4000; // Declared as an enum type.

// Method-only constants
pub const ACC_SYNCHRONIZED: u16 = 0x0020; // (Method) Declared synchronized; invocation is wrapped by a monitor use.
pub const ACC_BRIDGE: u16 = 0x0040; // (Method) A bridge, generated by the compiler.
pub const ACC_VARARGS: u16 = 0x0080; // (Method) Declared with variable number of arguments.
pub const ACC_NATIVE: u16 = 0x0100; // (Method) Declared native; implemented in a language other than Java.
pub const ACC_ABSTRACT_M: u16 = 0x0400; // (Method) Declared abstract; no implementation is provided.
pub const ACC_STRICT: u16 = 0x0800; // (Method) Declared strictfp; floating-point mode is FP-strict.

// CPType constants
pub const UTF8: u8 = 1;
pub const INTEGER: u8 = 3;
pub const FLOAT: u8 = 4;
pub const LONG: u8 = 5;
pub const DOUBLE: u8 = 6;
pub const CLASS: u8 = 7;
pub const STRING: u8 = 8;
pub const FIELDREF: u8 = 9;
pub const METHODREF: u8 = 10;
pub const INTERFACE_METHODREF: u8 = 11;
pub const NAMEANDTYPE: u8 = 12;
pub const METHODHANDLE: u8 = 15;
pub const METHODTYPE: u8 = 16;
pub const INVOKEDYNAMIC: u8 = 18;

#[derive(Clone)]
pub enum cp_entry {
    utf8 { val: String },
    integer { val: i32 },
    float { val: f32 },
    long { val: i64 },
    double { val: f64 },
    class { idx: u16 },
    string { idx: u16 },
    fieldref { clz_idx: u16, nt_idx: u16 },
    methodref { clz_idx: u16, nt_idx: u16 },
    interface_methodref { clz_idx: u16, nt_idx: u16 },
    name_and_type { name_idx: u16, type_idx: u16 },
}

impl cp_entry {
    pub fn separator(cp_type: u8) -> String {
        match cp_type {
            FIELDREF => ".".to_string(),
            METHODREF => ".".to_string(),
            NAMEANDTYPE => ":".to_string(),
            _ => "".to_string(),
        }
    }
}

pub struct cp_attr {
    name_idx: u16,
}

pub struct cp_field {
    class_name: String,
    flags: u16,
    name_idx: u16,
    desc_idx: u16,
    name: String,
    attrs: Vec<cp_attr>,
    // private JVMType type;
}

impl cp_field {
    fn new(
        klass_name: &String,
        field_name: String,
        field_flags: u16,
        name: u16,
        desc: u16,
    ) -> cp_field {
        cp_field {
            class_name: klass_name.to_string(),
            // FIXME
            flags: field_flags,
            name_idx: name,
            desc_idx: desc,
            name: field_name,
            attrs: Vec::new(),
        }
    }

    fn set_attr(&self, index: u16, attr: cp_attr) -> () {}
}

impl fmt::Display for cp_field {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}.{}:{}", self.class_name, self.name, self.desc_idx)
    }
}

pub struct cp_method {
    class_name: String,
    flags: u16,
    name_idx: u16,
    desc_idx: u16,
    name: String,
    attrs: Vec<cp_attr>,
    code: Vec<u8>,
}

impl cp_method {
    fn new(
        klass_name: &String,
        field_name: String,
        field_flags: u16,
        name: u16,
        desc: u16,
    ) -> cp_method {
        cp_method {
            class_name: klass_name.to_string(),
            // FIXME
            flags: field_flags,
            name_idx: name,
            desc_idx: desc,
            name: field_name,
            attrs: Vec::new(),
            code: Vec::new(),
        }
    }

    fn set_attr(&self, index: u16, attr: cp_attr) -> () {}
}

impl fmt::Display for cp_method {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}.{}:{}()", self.class_name, self.name, self.desc_idx)
    }
}

pub struct oc_parser {
    clz_read: Vec<u8>,
    filename: String,
    current: usize,
    major: u16,
    minor: u16,

    poolItemCount: u16,
    flags: u16,
    cp_index_this: u16,
    cp_index_super: u16,
    cp_items: Vec<cp_entry>,
    interfaces: Vec<u16>,
    fields: Vec<cp_field>,
    methods: Vec<cp_method>,
    // private CPAttr[] attributes;
}

impl oc_parser {
    pub fn new(buf: Vec<u8>, fname: String) -> oc_parser {
        oc_parser {
            clz_read: buf,
            filename: fname,
            current: 0,
            major: 0,
            minor: 0,
            poolItemCount: 0,
            flags: 0,
            cp_index_this: 0,
            cp_index_super: 0,
            cp_items: Vec::new(),
            interfaces: Vec::new(),
            fields: Vec::new(),
            methods: Vec::new(),
        }
    }

    pub fn klass(&mut self) -> runtime::OCKlass {
        runtime::OCKlass::of(self.klass_name().to_string(), self.super_name().to_string())
    }

    fn klass_name(&self) -> &String {
        // Lookup the name in the CP - note that CP indices are 1-indexed
        match self.cp_items[self.cp_index_this as usize] {
            cp_entry::class { idx: icl } => match &self.cp_items[icl as usize] {
                cp_entry::utf8 { val: s } => s,
                _ => panic!(
                    "Class index {} does not point at utf8 string in constant pool",
                    icl
                ),
            },
            _ => panic!(
                "Self-index {} does not point at class element in constant pool",
                self.cp_index_this
            ),
        }
    }

    fn super_name(&mut self) -> &String {
        // Lookup the superclass name in the CP - note that CP indices are 1-indexed
        match self.cp_items[self.cp_index_super as usize] {
            cp_entry::class { idx: scl } => match &self.cp_items[scl as usize] {
                cp_entry::utf8 { val: s } => s,
                _ => panic!(
                    "Superclass index {} does not point at utf8 string in constant pool",
                    scl
                ),
            },
            _ => panic!(
                "Super-index {} does not point at class element in constant pool",
                self.cp_index_this
            ),
        }
    }

    fn stringref_from_cp(&mut self, idx: u16) -> &String {
        match &self.cp_items[idx as usize] {
            cp_entry::utf8 { val: s } => s,
            _ => panic!(
                "Superclass index {} does not point at utf8 string in constant pool",
                idx
            ),
        }
    }

    pub fn parse(&mut self) -> () {
        self.parse_header();
        self.parse_constant_pool();
        self.parse_basic_type_info();
        self.parse_fields();
        // self.parseMethods();
        //        self.parseAttributes();
    }

    // CP is 1-indexed
    pub fn get_pool_size(&self) -> u16 {
        self.poolItemCount - 1
    }

    // Impl methods
    fn parse_header(&mut self) -> () {
        if self.clz_read[0] != 0xca
            || self.clz_read[1] != 0xfe
            || self.clz_read[2] != 0xba
            || self.clz_read[3] != 0xbe
        {
            panic!(
                "Input file {} does not have correct magic number",
                self.filename
            );
        }

        self.minor = ((self.clz_read[4] as u16) << 8) + self.clz_read[5] as u16;
        self.major = ((self.clz_read[6] as u16) << 8) + self.clz_read[7] as u16;
        self.poolItemCount = ((self.clz_read[8] as u16) << 8) + self.clz_read[9] as u16;
    }

    fn parse_constant_pool(&mut self) -> () {
        self.current = 10;
        println!("Pool size: {}", self.get_pool_size());
        self.cp_items
            .resize((self.poolItemCount as usize) + 1, cp_entry::integer { val: 0 });
        let mut current_cp = 1;
        let mut additional = false;
        while current_cp < self.poolItemCount {
            additional = false;
            let tag = self.clz_read[self.current];
            println!("Seen: {} at {}", tag, current_cp);
            self.current += 1;
            let item = match tag {
                UTF8 => {
                    println!("Parsing a utf8 at {}", current_cp);
                    let b1 = self.clz_read[self.current];
                    let b2 = self.clz_read[self.current + 1];
                    self.current += 2;

                    let len = ((b1 as u16) << 8) + b2 as u16;

                    let mut buf = vec![];
                    let mut chunk = self.clz_read[self.current..].take(len as u64);
                    chunk.read_to_end(&mut buf);
                    self.current += len as usize;

                    let str_c = match str::from_utf8(&buf) {
                        Ok(v) => v,
                        Err(e) => panic!("{}", e),
                    }
                    .to_owned();
                    println!("Parsed: {}", str_c);
                    cp_entry::utf8 { val: str_c }
                }
                INTEGER => {
                    let b1 = self.clz_read[self.current];
                    let b2 = self.clz_read[self.current + 1];
                    let b3 = self.clz_read[self.current + 2];
                    let b4 = self.clz_read[self.current + 3];
                    self.current += 4;

                    let buf = &[b1, b2, b3, b4];
                    cp_entry::integer {
                        val: BigEndian::read_i32(buf),
                    }
                }
                FLOAT => {
                    let b1 = self.clz_read[self.current];
                    let b2 = self.clz_read[self.current + 1];
                    let b3 = self.clz_read[self.current + 2];
                    let b4 = self.clz_read[self.current + 3];
                    self.current += 4;

                    let buf = &[b1, b2, b3, b4];
                    cp_entry::float {
                        val: BigEndian::read_f32(buf),
                    }
                }

                LONG => {
                    let b1 = self.clz_read[self.current];
                    let b2 = self.clz_read[self.current + 1];
                    let b3 = self.clz_read[self.current + 2];
                    let b4 = self.clz_read[self.current + 3];
                    let b5 = self.clz_read[self.current + 4];
                    let b6 = self.clz_read[self.current + 5];
                    let b7 = self.clz_read[self.current + 6];
                    let b8 = self.clz_read[self.current + 7];
                    self.current += 8;
                    // Longs are double width
                    additional = true;

                    let buf = &[b1, b2, b3, b4, b5, b6, b7, b8];
                    cp_entry::long {
                        val: BigEndian::read_i64(buf),
                    }
                }

                DOUBLE => {
                    let b1 = self.clz_read[self.current];
                    let b2 = self.clz_read[self.current + 1];
                    let b3 = self.clz_read[self.current + 2];
                    let b4 = self.clz_read[self.current + 3];
                    let b5 = self.clz_read[self.current + 4];
                    let b6 = self.clz_read[self.current + 5];
                    let b7 = self.clz_read[self.current + 6];
                    let b8 = self.clz_read[self.current + 7];
                    self.current += 8;
                    // Doubles are double width
                    additional = true;

                    let buf = &[b1, b2, b3, b4, b5, b6, b7, b8];
                    cp_entry::double {
                        val: BigEndian::read_f64(buf),
                    }
                }
                CLASS => {
                    // println!("Parsing a class");
                    let b1 = self.clz_read[self.current];
                    let b2 = self.clz_read[self.current + 1];
                    self.current += 2;

                    cp_entry::class {
                        idx: ((b1 as u16) << 8) + b2 as u16,
                    }
                }
                STRING => {
                    let b1 = self.clz_read[self.current];
                    let b2 = self.clz_read[self.current + 1];
                    self.current += 2;

                    cp_entry::string {
                        idx: ((b1 as u16) << 8) + b2 as u16,
                    }
                }
                FIELDREF => {
                    // println!("Parsing a fieldref");
                    let b1 = self.clz_read[self.current];
                    let b2 = self.clz_read[self.current + 1];
                    let b3 = self.clz_read[self.current + 2];
                    let b4 = self.clz_read[self.current + 3];
                    self.current += 4;

                    cp_entry::fieldref {
                        clz_idx: ((b1 as u16) << 8) + b2 as u16,
                        nt_idx: ((b3 as u16) << 8) + b4 as u16,
                    }
                }
                METHODREF => {
                    // println!("Parsing a methodref");
                    let b1 = self.clz_read[self.current];
                    let b2 = self.clz_read[self.current + 1];
                    let b3 = self.clz_read[self.current + 2];
                    let b4 = self.clz_read[self.current + 3];
                    self.current += 4;

                    cp_entry::methodref {
                        clz_idx: ((b1 as u16) << 8) + b2 as u16,
                        nt_idx: ((b3 as u16) << 8) + b4 as u16,
                    }
                }
                INTERFACE_METHODREF => {
                    // println!("Parsing an interface_methodref");
                    let b1 = self.clz_read[self.current];
                    let b2 = self.clz_read[self.current + 1];
                    let b3 = self.clz_read[self.current + 2];
                    let b4 = self.clz_read[self.current + 3];
                    self.current += 4;

                    cp_entry::interface_methodref {
                        clz_idx: ((b1 as u16) << 8) + b2 as u16,
                        nt_idx: ((b3 as u16) << 8) + b4 as u16,
                    }
                }
                NAMEANDTYPE => {
                    // println!("Parsing a name_and_type");
                    let b1 = self.clz_read[self.current];
                    let b2 = self.clz_read[self.current + 1];
                    let b3 = self.clz_read[self.current + 2];
                    let b4 = self.clz_read[self.current + 3];
                    self.current += 4;

                    cp_entry::name_and_type {
                        name_idx: ((b1 as u16) << 8) + b2 as u16,
                        type_idx: ((b3 as u16) << 8) + b4 as u16,
                    }
                }
                _ => panic!("Unsupported Constant Pool type {} at {}", tag, self.current),
            };
            self.cp_items[current_cp as usize] = item;
            current_cp += 1;
            if additional {
                current_cp += 1;
            }
        
        }
    }

    fn parse_basic_type_info(&mut self) -> () {
        self.flags =
            ((self.clz_read[self.current] as u16) << 8) + self.clz_read[self.current + 1] as u16;
        self.cp_index_this = ((self.clz_read[self.current + 2] as u16) << 8)
            + self.clz_read[self.current + 3] as u16;
        self.cp_index_super = ((self.clz_read[self.current + 4] as u16) << 8)
            + self.clz_read[self.current + 5] as u16;
        let count = ((self.clz_read[self.current + 6] as u16) << 8)
            + self.clz_read[self.current + 7] as u16;
        self.current += 8;

        for i in 0..count {
            self.interfaces.push(
                ((self.clz_read[self.current] as u16) << 8)
                    + self.clz_read[self.current + 1] as u16,
            );
            self.current += 2;
        }
    }

    fn parse_fields(&mut self) -> () {
        let fCount =
            ((self.clz_read[self.current] as u16) << 8) + self.clz_read[self.current + 1] as u16;
        self.current += 2;

        for idx in 0..fCount {
            let fFlags = ((self.clz_read[self.current] as u16) << 8)
                + self.clz_read[self.current + 1] as u16;
            let name_idx = ((self.clz_read[self.current + 2] as u16) << 8)
                + self.clz_read[self.current + 3] as u16;
            let desc_idx = ((self.clz_read[self.current + 4] as u16) << 8)
                + self.clz_read[self.current + 5] as u16;
            let attr_count = ((self.clz_read[self.current + 6] as u16) << 8)
                + self.clz_read[self.current + 7] as u16;
            self.current += 8;

            let f_name = match &self.cp_items[name_idx as usize] {
                cp_entry::utf8 { val: s } => s,
                _ => panic!(
                    "Name index {} does not point at utf8 string in constant pool",
                    name_idx
                ),
            };
            // NOTE: have just thrashed about to get the borrow checker to shut up here... need to revisit
            let mut k_name = &self.klass_name().to_string();
            let f = cp_field::new(&k_name, f_name.to_string(), fFlags, name_idx, desc_idx);
            for aidx in 0..attr_count {
                f.set_attr(aidx, self.parse_field_attribute(&f));
            }
            self.fields.push(f);
        }
    }

    fn parse_field_attribute(&mut self, field: &cp_field) -> cp_attr {
        let name_idx =
            ((self.clz_read[self.current] as u16) << 8) + self.clz_read[self.current + 1] as u16;
        let b1 = self.clz_read[self.current + 2];
        let b2 = self.clz_read[self.current + 3];
        let b3 = self.clz_read[self.current + 4];
        let b4 = self.clz_read[self.current + 5];
        self.current += 6;

        let buf = &[b1, b2, b3, b4];
        // Fix me - is this actually u32 (check spec)
        let attr_len = BigEndian::read_u32(buf);
        let end_index = self.current + attr_len as usize;

        let s = self.stringref_from_cp(name_idx).as_str();

        // The attributes defined by this spec as appearing in the attributes table of a field_info structure are:
        //
        // * ConstantValue (§4.7.2),
        // * Synthetic (§4.7.8),
        // * Signature (§4.7.9),
        // * Deprecated (§4.7.15),
        // * RuntimeVisibleAnnotations (§4.7.16)
        // * RuntimeInvisibleAnnotations (§4.7.17).
        match s {
            // FIXME: Actually parse this instead of skipping
            "ConstantValue" => self.current += 2,
            _ => panic!("Unsupported attribute {} seen on {}", s, field),
        }

        if self.current != end_index {
            panic!(
                "Inconsistent attribute index seen at {}, expected position {}",
                self.current, end_index
            )
        }
        cp_attr { name_idx: name_idx }
    }

    fn parse_method_attribute(&mut self, method: &cp_method) -> cp_attr {
        let name_idx =
            ((self.clz_read[self.current] as u16) << 8) + self.clz_read[self.current + 1] as u16;
        let b1 = self.clz_read[self.current + 2];
        let b2 = self.clz_read[self.current + 3];
        let b3 = self.clz_read[self.current + 4];
        let b4 = self.clz_read[self.current + 5];
        self.current += 6;

        let buf = &[b1, b2, b3, b4];
        // Fix me - is this actually u32 (check spec)
        let attr_len = BigEndian::read_u32(buf);
        let end_index = self.current + attr_len as usize;

        let s = self.stringref_from_cp(name_idx).as_str();
        match s {
            "Code" => {
                //    u2 max_stack;
                //    u2 max_locals;
                //    FIXME: Currently Don't care about stack depth or locals
                self.current += 4;
                // //    u4 code_length;
                // //    u1 code[code_length];
                let b1 = self.clz_read[self.current];
                let b2 = self.clz_read[self.current + 1];
                let b3 = self.clz_read[self.current + 2];
                let b4 = self.clz_read[self.current + 3];
                self.current += 4;

                let buf = &[b1, b2, b3, b4];
                // FIXME: Is this actually u32?
                let code_len = BigEndian::read_u32(buf);

                let mut bytecode = vec![];
                let mut chunk = self.clz_read[self.current..].take(code_len as u64);
                chunk.read_to_end(&mut bytecode);
            }
            //    u2 exception_table_length;
            //    {   u2 start_pc;
            //        u2 end_pc;
            //        u2 handler_pc;
            //        u2 catch_type;
            //    } exception_table[exception_table_length];
            //    u2 attributes_count;
            //    attribute_info attributes[attributes_count];
            "Exceptions" => panic!("Encountered exception handlers in bytecode - skipping"),
            _ => panic!("Unsupported attribute {} seen on {}", s, method),
        }

        if self.current != end_index {
            panic!(
                "Inconsistent attribute index seen at {}, expected position {}",
                self.current, end_index
            )
        }
        cp_attr { name_idx: name_idx }
    }

    //         int nameCPIdx = ((int) clzBytes[current++] << 8) + (int) clzBytes[current++];
    //         int attrLen = ((int) clzBytes[current++] << 24) + ((int) clzBytes[current++] << 16) + ((int) clzBytes[current++] << 8) + (int) clzBytes[current++];
    //         int endIndex = current + attrLen;

    //         // Now check to see what type of attribute it is...
    //         String s = getCPEntry(nameCPIdx).getStr();

    //         // E.g. for fields....
    //         //
    // //        The attributes defined by this specification as appearing in the attributes table of a field_info structure are ConstantValue (§4.7.2), Synthetic (§4.7.8), Signature (§4.7.9), Deprecated (§4.7.15), RuntimeVisibleAnnotations (§4.7.16) and RuntimeInvisibleAnnotations (§4.7.17).
    //         // FIXME
    //         switch (s) {
    //             case "ConstantValue":
    //                 if (b instanceof CPMethod) {
    //                     CPMethod m = (CPMethod) b;
    //                     String methDesc = resolveAsString(m.nameIndex) + ":" + resolveAsString(m.descIndex);
    //                     throw new IllegalArgumentException("Method " + methDesc + " cannot be a constant");
    //                 }
    //                 // FIXME
    //                 current += 2;
    //                 break;
    //             case "Code":
    //                 if (b instanceof CPField) {
    //                     CPField f = (CPField) b;
    //                     String fieldDesc = resolveAsString(f.nameIndex) + ":" + resolveAsString(f.descIndex);
    //                     throw new IllegalArgumentException("Field " + fieldDesc + " cannot contain code");
    //                 }
    //                 final CPMethod m = (CPMethod) b;
    // //    u2 max_stack;
    // //    u2 max_locals;
    //                 // Don't care about stack depth or locals
    //                 current += 4;
    // //    u4 code_length;
    // //    u1 code[code_length];
    //                 int codeLen = ((int) clzBytes[current++] << 24) + ((int) clzBytes[current++] << 16) + ((int) clzBytes[current++] << 8) + (int) clzBytes[current++];
    //                 byte[] bytecode = Arrays.copyOfRange(clzBytes, current, current + codeLen);
    //                 m.setBytecode(bytecode);
    // //    u2 exception_table_length;
    // //    {   u2 start_pc;
    // //        u2 end_pc;
    // //        u2 handler_pc;
    // //        u2 catch_type;
    // //    } exception_table[exception_table_length];
    // //    u2 attributes_count;
    // //    attribute_info attributes[attributes_count];
    //                 break;
    //             case "Exceptions":
    //                 System.err.println("Encountered exception handlers in bytecode - skipping");
    //                 break;
    //             default:
    //                 throw new IllegalArgumentException("Input file has unhandled Attribute type: " + s);
    //         }
    //         // Skip to the end
    //         current = endIndex;

    //         return new CPAttr(nameCPIdx);
}
