use std::slice::Iter;
use std::vec::IntoIter;

pub const ACC_PUBLIC: u16 = 0x0001; // Declared public; may be accessed from outside its package.
pub const ACC_PRIVATE: u16 = 0x0002; // Declared private; usable only within the defining class.
pub const ACC_PROTECTED: u16 = 0x0004; // Declared protected; may be accessed within subclasses.
pub const ACC_STATIC: u16 = 0x0008; // Declared static

pub const ACC_FINAL: u16 = 0x0010; // Declared final; no subclasses allowed.
pub const ACC_SUPER: u16 = 0x0020; // (Class) Treat superclass methods specially when invoked by the invokespecial instruction.
pub const ACC_VOLATILE: u16 = 0x0040; // (Field) Declared volatile; cannot be cached.
pub const ACC_TRANSIENT: u16 = 0x0080; // (Field) Declared transient; not written or read by a persistent object manager.
pub const ACC_INTERFACE: u16 = 0x0200; // (Class) Is an interface, not a class.
pub const ACC_ABSTRACT: u16 = 0x0400; // (Class) Declared abstract; must not be instantiated.
pub const ACC_SYNTHETIC: u16 = 0x1000; // Declared synthetic; not present in the source code.
pub const ACC_ANNOTATION: u16 = 0x2000; // Declared as an annotation type.
pub const ACC_ENUM: u16 = 0x4000; // Declared as an enum type.

// Method-only constants
pub const ACC_SYNCHRONIZED: u16 = 0x0020; // (Method) Declared synchronized; invocation is wrapped by a monitor use.
pub const ACC_BRIDGE: u16 = 0x0040; // (Method) A bridge, generated by the compiler.
pub const ACC_VARARGS: u16 = 0x0080; // (Method) Declared with variable number of arguments.
pub const ACC_NATIVE: u16 = 0x0100; // (Method) Declared native; implemented in a language other than Java.
pub const ACC_ABSTRACT_M: u16 = 0x0400; // (Method) Declared abstract; no implementation is provided.
pub const ACC_STRICT: u16 = 0x0800; // (Method) Declared strictfp; floating-point mode is FP-strict.

pub struct oc_parser {
    clz_iter: IntoIter<u8>,
    filename: String,

    major: u16,
    minor: u16,

    poolItemCount: u16,
    // private final static CPType[] table = new CPType[256];
    current: u16,

    flags: u16,
    thisClzIndex: u16,
    superClzIndex: u16,
    // private CPEntry[] items;
    // private int[] interfaces;
    // private CPField[] fields;
    // private CPMethod[] methods;
    // private CPAttr[] attributes;
}

impl oc_parser {
    pub fn new(buf: Vec<u8>, fname: String) -> oc_parser {
        oc_parser {
            clz_iter: buf.into_iter(),
            filename: fname,
            major: 0,
            minor: 0,
            poolItemCount: 0,
            current: 0,
            flags: 0,
            thisClzIndex: 0,
            superClzIndex: 0,
        }
    }

    pub fn parse(&mut self) -> () {
        self.current = 0;
        self.parse_header();
        // self.parseConstantPool();
        // self.parseBasicTypeInfo();
        // self.parseFields();
        // self.parseMethods();
        //        self.parseAttributes();
    }

    fn get_byte(&mut self, pos: usize) -> u8 {
        0
    }

    fn parse_header(&mut self) -> () {
        if self.clz_iter.next().unwrap_or(0x00) != 0xca
            || self.clz_iter.next().unwrap_or(0x00) != 0xfe
            || self.clz_iter.next().unwrap_or(0x00) != 0xba
            || self.clz_iter.next().unwrap_or(0x00) != 0xbe
        {
            panic!(
                "Input file {} does not have correct magic number",
                self.filename
            );
        }

        self.minor = ((self.clz_iter.next().unwrap_or(0x00) << 8) as u16)
            + self.clz_iter.next().unwrap_or(0x00) as u16;
        self.major = ((self.clz_iter.next().unwrap_or(0x00) << 8) as u16)
            + self.clz_iter.next().unwrap_or(0x00) as u16;
        self.poolItemCount = ((self.clz_iter.next().unwrap_or(0x00) << 8) as u16)
            + self.clz_iter.next().unwrap_or(0x00) as u16;
    }
}
